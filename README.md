# GenericSpecializationGenerator

Provides generic type specialization.

## What's this?

This is a source generator that achieves specialization of .Net generic methods,
similar to template specialization in C++.

Considering the nature of JIT, it can generate source code with very low overhead,
especially in release builds.

## Usage

```CSharp
using GenericSpecialization.DebugApp;

partial class SampleInstanceClass
{
    // Add `PrimaryGenericAttribute` to generic method declaration
    // with a parameter of the method name which will be called for default code path.
    [PrimaryGeneric(nameof(FooDefault))]
    public partial void Foo<T>(T input);

    // Define default implementation of target generic method.
    private void FooDefault<T>(T input)
    {
        Console.WriteLine($"default");
    }

    // Write non-generic method which has same signature with the closed of target generic method declaration.
    // They will be detected automatically and be treated as implementation of generic specialization.
    private void Foo(int input)
    {
        Console.WriteLine($"int specialized");
    }

    // Write non-generic method which has same signature with the closed of target generic method declaration.
    // They will be detected automatically and be treated as implementation of generic specialization.
    private void Foo(double input)
    {
        Console.WriteLine($"double specialized");
    }
}
```

Against the preceding code, this generator will generate such as following code:

```CSharp
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604
using System.Runtime.CompilerServices;
namespace GenericSpecializationGenerator.DebugApp;

partial class SampleInstanceClass
{
    public partial void Foo<T>(T input)
    {
        if(typeof(T) == typeof(Int32))
        {
            var _input = Unsafe.As<T, int>(ref input);
            Foo(_input);
            return;
        }
        if(typeof(T) == typeof(Double))
        {
            var _input = Unsafe.As<T, double>(ref input);
            Foo(_input);
            return;
        }
        FooDefault(input);
        return;
    }
}
```

### Rules

- Both of instance and static methods are supported.
  - If primary generic method is an instance method,
    both of instance and static methods are available as specialization or default.
  - If primary generic method is a static method,
    only static methods are available as specialization or default.
- Primary generic method declaration must has accessibility modifier.
- Generic specialization method must has same signature with primary generic method except that the generic type arguments are replaced by concrete types.
- Generic specialization method must be in the same class with primary generic method declaration.

### Limitation

These might be changed in future.

- Partial specialization is not supported now.
  - where only some of the multiple type arguments are determined
  - where type constraints become stricter instead of concrete types being substituted
- Types that can be derived is not supported now.

## License

Apache License Version 2.0
