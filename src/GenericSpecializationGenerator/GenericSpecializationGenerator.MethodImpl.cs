using System.Text;
using Microsoft.CodeAnalysis;

namespace GenericSpecializationGenerator;

partial class GenericSpecializationGenerator
{
    private abstract class GenerationLogic
    {
        protected GenerationLogic() { }

        public string GenerateSpecializedMethod(
        INamedTypeSymbol ownerClass,
        MethodDeclarationInfo method,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
        {
            var ns = ownerClass.ContainingNamespace.IsGlobalNamespace
                ? ""
                : $"namespace {ownerClass.ContainingNamespace};";

            SourceCodeGenerationHandler generator = $$"""
            // <auto-generated/>
            #nullable enable
            #pragma warning disable CS8600
            #pragma warning disable CS8601
            #pragma warning disable CS8602
            #pragma warning disable CS8603
            #pragma warning disable CS8604
            using System.Runtime.CompilerServices;
            {{ns}}

            partial class {{ownerClass.Name}}
            {
                [MethodImpl(MethodImplOptions.AggressiveOptimization)]
                {{method}}
                {
                    {{specializedMethods.Select(GetSpecializedCode)}}
                    {{GetDefaultReturn(method.Symbol, defaultMethodName)}}
                }
            }
            """;
            return generator.ToString();
        }

        protected SourceCodeGenerationHandler GetSpecializedCode(MethodSpecialization specialized)
        {
            var methodSymbol = specialized.PrimaryMethod;
            var condition = GetCondition(methodSymbol.TypeArguments, specialized.ClosedTypeArgs);
            var paramMaps = methodSymbol.Parameters.Zip(specialized.SpecializedMethod.Parameters, (x, y) => (arg: x, mapped: y));
            SourceCodeGenerationHandler generator = $$"""
            if({{condition}})
            {
                {{paramMaps.ForeachIndented(tpl => GetVariableCast(specialized, tpl))}}
                {{GetReturn(methodSymbol, specialized)}}
            }
            """;
            return generator;
        }

        protected abstract SourceCodeGenerationHandler GetReturn(IMethodSymbol methodSymbol, MethodSpecialization specialized);

        protected abstract SourceCodeGenerationHandler GetDefaultReturn(IMethodSymbol methodSymbol, string defaultMethodName);

        private static string GetCondition(IEnumerable<ITypeSymbol> openTypeArgs, IEnumerable<INamedTypeSymbol> closedTypeArgs)
        {
            static string core(ITypeSymbol open, INamedTypeSymbol closed)
                => closed.IsValueType
                ? $"typeof({open}) == typeof({closed})"
                : $"typeof({closed}).IsAssignableFrom(typeof({open}))";

            return string.Join(" && ", openTypeArgs.Zip(closedTypeArgs, core));
        }

        private static string GetVariableCast(MethodSpecialization specialized, (IParameterSymbol arg, IParameterSymbol mapped) tpl)
        {
            var (arg, mapped) = tpl;
            return $"var {specialized.VariablePrefix}{mapped.Name} = Unsafe.As<{arg.Type}, {mapped.Type}>(ref {arg.Name});";
        }
    }


    private class GenerationVoidReturnLogic : GenerationLogic
    {
        public static GenerationLogic Instance { get; } = new GenerationVoidReturnLogic();

        protected override SourceCodeGenerationHandler GetReturn(IMethodSymbol methodSymbol, MethodSpecialization specialized)
            => $$"""
            {{methodSymbol.Name}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{specialized.VariablePrefix}{arg.Name}"))}});
            return;
            """;

        protected override SourceCodeGenerationHandler GetDefaultReturn(IMethodSymbol methodSymbol, string defaultMethodName)
            => $$"""
            {{defaultMethodName}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{arg.Name}"))}});
            return;
            """;
    }


    private class GenerationNonVoidReturnLogic : GenerationLogic
    {
        public static GenerationLogic Instance { get; } = new GenerationNonVoidReturnLogic();

        protected override SourceCodeGenerationHandler GetReturn(IMethodSymbol methodSymbol, MethodSpecialization specialized)
            => $$"""
            var {{specialized.VariablePrefix}}retval = {{methodSymbol.Name}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{specialized.VariablePrefix}{arg.Name}"))}});
            return Unsafe.As<{{specialized.SpecializedMethod.ReturnType}}, {{methodSymbol.ReturnType}}>(ref {{specialized.VariablePrefix}}retval);
            """;

        protected override SourceCodeGenerationHandler GetDefaultReturn(IMethodSymbol methodSymbol, string defaultMethodName)
            => $$"""
            return {{defaultMethodName}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{arg.Name}"))}});
            """;
    }


    private static string GenerateSpecializedMethod(
        INamedTypeSymbol ownerClass,
        MethodDeclarationInfo method,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
    {
        var logic = method.Symbol.ReturnType.SpecialType == SpecialType.System_Void
            ? GenerationVoidReturnLogic.Instance
            : GenerationNonVoidReturnLogic.Instance;
        return logic.GenerateSpecializedMethod(ownerClass, method, defaultMethodName, specializedMethods);
    }


}
