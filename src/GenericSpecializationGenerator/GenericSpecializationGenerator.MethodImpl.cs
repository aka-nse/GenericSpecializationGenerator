using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GenericSpecializationGenerator;

partial class GenericSpecializationGenerator
{
    private const string _SharedHeader = """
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604
using System.Runtime.CompilerServices;

""";

    private static string GenerateSpecializedMethod(
        INamedTypeSymbol ownerClass,
        MethodDeclarationSyntax methodNode,
        IMethodSymbol methodSymbol,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
        => methodSymbol.ReturnType.SpecialType == SpecialType.System_Void
        ? GenerateSpecializedMethodVoid(ownerClass, methodNode, methodSymbol, defaultMethodName, specializedMethods)
        : GenerateSpecializedMethodNotVoid(ownerClass, methodNode, methodSymbol, defaultMethodName, specializedMethods);

    private static string GenerateSpecializedMethodVoid(
        INamedTypeSymbol ownerClass,
        MethodDeclarationSyntax methodNode,
        IMethodSymbol methodSymbol,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
    {
        var ns = ownerClass.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {ownerClass.ContainingNamespace};";

        var sb = new StringBuilder();
        sb.AppendLine(_SharedHeader);
        sb.AppendLine($$"""
{{ns}}

partial class {{ownerClass.Name}}
{
    {{string.Join(" ", methodNode.Modifiers)}} {{methodNode.ReturnType}} {{methodSymbol.Name}}{{methodNode.TypeParameterList}}{{methodNode.ParameterList}}
    {
""");

        foreach (var specialized in specializedMethods.OrderBy(x => x, MethodSpecializationComparer.Instance))
        {
            var condition = GetCondition(methodSymbol.TypeArguments, specialized.ClosedTypeArgs);
            sb.AppendLine($$"""
        if({{condition}})
        {
""");
            foreach (var (arg, mapped) in methodSymbol.Parameters.Zip(specialized.SpecializedMethod.Parameters, (x, y) => (x, y)))
            {
                sb.AppendLine($$"""
            var __{{arg.Name}}__ = Unsafe.As<{{arg.Type}}, {{mapped.Type}}>(ref {{arg.Name}});
""");
            }
            sb.AppendLine($$"""
            {{methodSymbol.Name}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"__{arg.Name}__"))}});
            return;
""");
            sb.AppendLine($$"""
        }
""");
        }

        sb.AppendLine($$"""
        {{defaultMethodName}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{arg.Name}"))}});
        return;
    }
}
""");
        return sb.ToString();
    }


    private static string GenerateSpecializedMethodNotVoid(
        INamedTypeSymbol ownerClass,
        MethodDeclarationSyntax methodNode,
        IMethodSymbol methodSymbol,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
    {
        var ns = ownerClass.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {ownerClass.ContainingNamespace};";

        var sb = new StringBuilder();
        sb.AppendLine(_SharedHeader);
        sb.AppendLine($$"""
{{ns}}

partial class {{ownerClass.Name}}
{
    {{string.Join(" ", methodNode.Modifiers)}} {{methodNode.ReturnType}} {{methodSymbol.Name}}{{methodNode.TypeParameterList}}{{methodNode.ParameterList}}
    {
""");

        foreach (var specialized in specializedMethods.OrderBy(x => x, MethodSpecializationComparer.Instance))
        {
            var condition = GetCondition(methodSymbol.TypeArguments, specialized.ClosedTypeArgs);
            sb.AppendLine($$"""
        if({{condition}})
        {
""");
            foreach (var (arg, mapped) in methodSymbol.Parameters.Zip(specialized.SpecializedMethod.Parameters, (x, y) => (x, y)))
            {
                sb.AppendLine($$"""
            var __{{arg.Name}}__ = Unsafe.As<{{arg.Type}}, {{mapped.Type}}>(ref {{arg.Name}});
""");
            }
            sb.AppendLine($$"""
            var __retval__ = {{methodSymbol.Name}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"__{arg.Name}__"))}});
            return Unsafe.As<{{specialized.SpecializedMethod.ReturnType}}, {{methodSymbol.ReturnType}}>(ref __retval__);
""");
            sb.AppendLine($$"""
        }
""");
        }

        sb.AppendLine($$"""
        return {{defaultMethodName}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{arg.Name}"))}});
    }
}
""");
        return sb.ToString();
    }

    private static string GetCondition(IEnumerable<ITypeSymbol> openTypeArgs, IEnumerable<INamedTypeSymbol> closedTypeArgs)
    {
        var sb = new StringBuilder();
        foreach (var (open, closed) in openTypeArgs.Zip(closedTypeArgs, (x, y) => (x, y)))
        {
            if (sb.Length > 0)
            {
                sb.Append(" && ");
            }

            sb.Append($"typeof({open.Name}) == typeof({closed.Name})");
        }
        return sb.ToString();
    }
}
