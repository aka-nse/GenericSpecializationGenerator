using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using SourceGeneratorToolkit;

namespace GenericSpecializationGenerator;

partial class GenericSpecializationGenerator
{
    private abstract class GenerationLogic
    {
        protected GenerationLogic() { }

        internal SourceBuilder GenerateSpecializedMethod(
            GeneratorAttributeSyntaxContext context,
            MethodDeclarationInfo method,
            string defaultMethodName,
            MethodSpecialization[] specializedMethods
            )
        {
            var builder = new SourceBuilder(context, false);
            builder.AppendLine($$"""
                {{builder.AutoGeneratedComment}}
                #pragma warning disable CS8600
                #pragma warning disable CS8601
                #pragma warning disable CS8602
                #pragma warning disable CS8603
                #pragma warning disable CS8604
                {{builder.DefaultUsingDirectives}}
                using __Unsafe = System.Runtime.CompilerServices.Unsafe;
                {{builder.NamespaceDeclaration}}

                """);
            using (builder.BeginTargetTypeDeclare())
            {

                builder.AppendLine($$"""
                    #if NETCOREAPP3_0_OR_GREATER
                    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
                    #endif
                    {{method}}
                    {
                        {{specializedMethods.Select(GetSpecializedCode).PreserveIndent()}}
                        {{GetDefaultReturn(method.Symbol, defaultMethodName).PreserveIndent()}}
                    }
                    """);
            }
            return builder;
        }

        protected SourceStringHandler GetSpecializedCode(MethodSpecialization specialized)
        {
            var methodSymbol = specialized.PrimaryMethod;
            var condition = GetCondition(methodSymbol.TypeArguments, specialized.ClosedTypeArgs);
            var paramMaps = methodSymbol.Parameters.Zip(specialized.SpecializedMethod.Parameters, (x, y) => (arg: x, mapped: y));
            SourceStringHandler generator = $$"""
            if({{condition}})
            {
                {{paramMaps.Select(tpl => GetVariableCast(specialized, tpl)).PreserveIndent()}}
                {{GetReturn(methodSymbol, specialized).PreserveIndent()}}
            }
            """;
            return generator;
        }

        protected abstract SourceStringHandler GetReturn(
            IMethodSymbol methodSymbol,
            MethodSpecialization specialized);

        protected abstract SourceStringHandler GetDefaultReturn(
            IMethodSymbol methodSymbol,
            string defaultMethodName);

        private static string GetCondition(
            IEnumerable<ITypeSymbol> openTypeArgs,
            IEnumerable<INamedTypeSymbol> closedTypeArgs)
        {
            static string core(ITypeSymbol open, INamedTypeSymbol closed)
                => closed.IsValueType
                ? $"typeof({open}) == typeof({closed})"
                : $"typeof({closed}).IsAssignableFrom(typeof({open}))";

            return string.Join(" && ", openTypeArgs.Zip(closedTypeArgs, core));
        }

        private static string GetVariableCast(
            MethodSpecialization specialized,
            (IParameterSymbol arg, IParameterSymbol mapped) tpl)
        {
            var (arg, mapped) = tpl;
            return arg.RefKind switch
            {
                RefKind.None => $"var {specialized.VariablePrefix}{mapped.Name} = __Unsafe.As<{arg.Type}, {mapped.Type}>(ref {arg.Name});",
                RefKind.In => $"ref var {specialized.VariablePrefix}{mapped.Name} = ref __Unsafe.As<{arg.Type}, {mapped.Type}>(ref __Unsafe.AsRef(in {arg.Name}));",
                RefKind.Ref => $"ref var {specialized.VariablePrefix}{mapped.Name} = ref __Unsafe.As<{arg.Type}, {mapped.Type}>(ref {arg.Name});",
                RefKind.Out => $"__Unsafe.SkipInit(out {arg.Name}); ref var {specialized.VariablePrefix}{mapped.Name} = ref __Unsafe.As<{arg.Type}, {mapped.Type}>(ref {arg.Name});",
                _ => throw new ArgumentException(),
            };
        }

        protected static string GetSpecializedCallParameters(
            IMethodSymbol methodSymbol,
            MethodSpecialization specialized)
        {
            string core(IParameterSymbol arg)
                => arg.RefKind switch
                {
                    RefKind.None => $"{specialized.VariablePrefix}{arg.Name}",
                    RefKind.In => $"in {specialized.VariablePrefix}{arg.Name}",
                    RefKind.Ref => $"ref {specialized.VariablePrefix}{arg.Name}",
                    RefKind.Out => $"out {specialized.VariablePrefix}{arg.Name}",
                    _ => throw new ArgumentException(),
                };

            return string.Join(", ", methodSymbol.Parameters.Select(core));
        }

        protected static string GetDefaultCallParameters(IMethodSymbol methodSymbol)
        {
            static string core(IParameterSymbol arg)
                => arg.RefKind switch
                {
                    RefKind.None => $"{arg.Name}",
                    RefKind.In => $"in {arg.Name}",
                    RefKind.Ref => $"ref {arg.Name}",
                    RefKind.Out => $"out {arg.Name}",
                    _ => throw new ArgumentException(),
                };

            return string.Join(", ", methodSymbol.Parameters.Select(core));
        }
    }


    private class GenerationVoidReturnLogic : GenerationLogic
    {
        public static GenerationLogic Instance { get; } = new GenerationVoidReturnLogic();

        protected override SourceStringHandler GetReturn(
            IMethodSymbol methodSymbol,
            MethodSpecialization specialized)
            => $$"""
            {{methodSymbol.Name}}({{GetSpecializedCallParameters(methodSymbol, specialized)}});
            return;
            """;

        protected override SourceStringHandler GetDefaultReturn(
            IMethodSymbol methodSymbol,
            string defaultMethodName)
            => $$"""
            {{defaultMethodName}}({{GetDefaultCallParameters(methodSymbol)}});
            return;
            """;
    }


    private class GenerationNonVoidReturnLogic : GenerationLogic
    {
        public static GenerationLogic Instance { get; } = new GenerationNonVoidReturnLogic();

        protected override SourceStringHandler GetReturn(
            IMethodSymbol methodSymbol,
            MethodSpecialization specialized)
            => $$"""
            var {{specialized.VariablePrefix}}retval = {{methodSymbol.Name}}({{GetSpecializedCallParameters(methodSymbol, specialized)}});
            return __Unsafe.As<{{specialized.SpecializedMethod.ReturnType}}, {{methodSymbol.ReturnType}}>(ref {{specialized.VariablePrefix}}retval);
            """;

        protected override SourceStringHandler GetDefaultReturn(
            IMethodSymbol methodSymbol,
            string defaultMethodName)
            => $$"""
            return {{defaultMethodName}}({{GetDefaultCallParameters(methodSymbol)}});
            """;
    }


    private static SourceBuilder GenerateSpecializedMethod(
        GeneratorAttributeSyntaxContext context,
        MethodDeclarationInfo method,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
    {
        var logic = method.Symbol.ReturnType.SpecialType == SpecialType.System_Void
            ? GenerationVoidReturnLogic.Instance
            : GenerationNonVoidReturnLogic.Instance;
        return logic.GenerateSpecializedMethod(context, method, defaultMethodName, specializedMethods);
    }
}
