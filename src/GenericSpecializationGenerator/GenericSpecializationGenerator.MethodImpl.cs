using System.Text;
using Microsoft.CodeAnalysis;

namespace GenericSpecializationGenerator;

partial class GenericSpecializationGenerator
{
    private abstract class GenerationLogic
    {
        protected GenerationLogic() { }

        public string GenerateSpecializedMethod(
        INamedTypeSymbol ownerClass,
        MethodDeclarationInfo method,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
        {
            var ns = ownerClass.ContainingNamespace.IsGlobalNamespace
                ? ""
                : $"namespace {ownerClass.ContainingNamespace};";

            var sb = new StringBuilder();
            sb.AppendLine($$"""
            // <auto-generated/>
            #nullable enable
            #pragma warning disable CS8600
            #pragma warning disable CS8601
            #pragma warning disable CS8602
            #pragma warning disable CS8603
            #pragma warning disable CS8604
            using System.Runtime.CompilerServices;
            {{ns}}

            partial class {{ownerClass.Name}}
            {
                {{method.ToString()}}
                {
            """);
            foreach (var specialized in specializedMethods.OrderBy(x => x, MethodSpecializationComparer.Instance))
            {
                WriteSpecializedCode(sb, method.Symbol, specialized);
            }
            WriteDefaultReturn(sb, method.Symbol, defaultMethodName);
            sb.AppendLine($$"""
                }
            }
            """);
            return sb.ToString();
        }

        protected void WriteSpecializedCode(StringBuilder sb, IMethodSymbol methodSymbol, MethodSpecialization specialized)
        {
            var condition = GetCondition(methodSymbol.TypeArguments, specialized.ClosedTypeArgs);
            var paramMaps = methodSymbol.Parameters.Zip(specialized.SpecializedMethod.Parameters, (x, y) => (x, y));
            sb.AppendLine($$"""
                    if({{condition}})
                    {
            """);
            foreach (var (arg, mapped) in paramMaps) sb.AppendLine($$"""
                        var __{{arg.Name}}__ = Unsafe.As<{{arg.Type}}, {{mapped.Type}}>(ref {{arg.Name}});
            """);
            WriteReturn(sb, methodSymbol, specialized);
            sb.AppendLine($$"""
                    }
            """);
        }

        protected abstract void WriteReturn(StringBuilder sb, IMethodSymbol methodSymbol, MethodSpecialization specialized);

        protected abstract void WriteDefaultReturn(StringBuilder sb, IMethodSymbol methodSymbol, string defaultMethodName);

        private static string GetCondition(IEnumerable<ITypeSymbol> openTypeArgs, IEnumerable<INamedTypeSymbol> closedTypeArgs)
        {
            var sb = new StringBuilder();
            foreach (var (open, closed) in openTypeArgs.Zip(closedTypeArgs, (x, y) => (x, y)))
            {
                if (sb.Length > 0)
                {
                    sb.Append(" && ");
                }

                sb.Append($"typeof({open.Name}) == typeof({closed.Name})");
            }
            return sb.ToString();
        }
    }


    private class GenerationVoidReturnLogic : GenerationLogic
    {
        public static GenerationLogic Instance { get; } = new GenerationVoidReturnLogic();

        protected override void WriteReturn(StringBuilder sb, IMethodSymbol methodSymbol, MethodSpecialization specialized)
        {
            sb.AppendLine($$"""
                        {{methodSymbol.Name}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"__{arg.Name}__"))}});
                        return;
            """);
        }

        protected override void WriteDefaultReturn(StringBuilder sb, IMethodSymbol methodSymbol, string defaultMethodName)
        {
            sb.AppendLine($$"""
                    {{defaultMethodName}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{arg.Name}"))}});
                    return;
            """);
        }
    }


    private class GenerationNonVoidReturnLogic : GenerationLogic
    {
        public static GenerationLogic Instance { get; } = new GenerationNonVoidReturnLogic();

        protected override void WriteReturn(StringBuilder sb, IMethodSymbol methodSymbol, MethodSpecialization specialized)
        {
            sb.AppendLine($$"""
                        var __retval__ = {{methodSymbol.Name}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"__{arg.Name}__"))}});
                        return Unsafe.As<{{specialized.SpecializedMethod.ReturnType}}, {{methodSymbol.ReturnType}}>(ref __retval__);
            """);
        }

        protected override void WriteDefaultReturn(StringBuilder sb, IMethodSymbol methodSymbol, string defaultMethodName)
        {
            sb.AppendLine($$"""
                    return {{defaultMethodName}}({{string.Join(", ", methodSymbol.Parameters.Select(arg => $"{arg.Name}"))}});
            """);
        }
    }


    private static string GenerateSpecializedMethod(
        INamedTypeSymbol ownerClass,
        MethodDeclarationInfo method,
        string defaultMethodName,
        MethodSpecialization[] specializedMethods)
    {
        var logic = method.Symbol.ReturnType.SpecialType == SpecialType.System_Void
            ? GenerationVoidReturnLogic.Instance
            : GenerationNonVoidReturnLogic.Instance;
        return logic.GenerateSpecializedMethod(ownerClass, method, defaultMethodName, specializedMethods);
    }


}
